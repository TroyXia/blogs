# 介绍

在写代码时遇到状态一定要留神，状态是否是幂等的。常用的状态除了成功，失败还有超时。超时是不知名的操作，可能由于多种原因超时。

如果对超时处理不好，容易出现程序不幂等的情况。

如 [示例 1](https://github.com/TroyXia/go-by-example/blob/main/uuid/uuid1/main.go) 所示。假如第一次后端扣减成功，但由于网络等原因，响应服务端超时。

那么，在下次执行同样操作时，将再次扣减，导致程序不幂等。

分析不幂等的原因在于：
1. 无法表示唯一性，不能通过请求判断当前操作是否是执行过的。
2. 程序中无记录，导致每次请求来都重新处理。

有了上述分析，可以生成 uuid，在每个请求中带上 uuid，后端服务通过该 uuid 确定是否请求被处理。接着，后端维护请求处理表，这张表记录了请求是否成功。我们知道成功，失败是幂等的。

可以通过 `"github.com/google/uuid"` 库生成 uuid，代码示例在 [这里](https://github.com/TroyXia/go-by-example/blob/main/uuid/uuid3/main.go)。

# 思考

幂等设计的核心在于 id 的唯一性，结合状态机我们也要知道 id 是唯一的。在 bmvo operator 开发中我们能保证幂等是因为 bmhc/bmhv 的名字是唯一的。bmhc/bmhv 就起了 uuid 的功能。否则，就算有状态机，也无法表示请求是唯一的。

比如，A 每次都要做电梯上 7 楼，中间可能会到 7 楼也可能到不了，通过状态机记录 A 的状态。下次在处理时根据 A 的状态继续处理到 7 楼的逻辑。能这么处理的原因在于 A 的名字/人脸是唯一的，系统可以根据名字/人脸确定这是 A，并且他
要去 7 楼。如果系统不知道 A 的名字/人脸，那么就需要 A 拿到全局唯一的号码牌（uuid）才能被系统给认出来，带他到 7 楼。

这里的重点不是状态机，是全局唯一。

# 参考资料

- [弹力设计：幂等性设计](https://time.geekbang.org/column/article/4050)
